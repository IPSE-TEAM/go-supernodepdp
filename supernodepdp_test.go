package go_supernodepdp

import (
	"crypto/rand"
	"fmt"
	"math/big"
	"testing"
)

func TestPDP(t *testing.T){
	// generate a 128-bit private key.
	privKey := KeyGen()

	// DistributionNode is the data owner
	data := "s100000"
	ciphertext := Setup(data,&privKey)

	// SuperNode store the ciphertext
	// SuperNode generate a challenge
	chalciphertext,chal,err := Challege(&privKey.PublicKey)
	if err != nil {
		fmt.Println(err)
		return
	}

	// StorageMiner Proof
	storedData := "s100000"
	proof := Proof(storedData,chal)

	// SuperNode verify
	res := Verify(&privKey,ciphertext,chalciphertext,proof)
	if res {
		fmt.Println("verify success")
	}else {
		fmt.Println("verify failed")
	}

}

func KeyGen() (PrivateKey) {
	privKey,err := GenerateKey(rand.Reader,128)
	if err != nil{
		fmt.Println(err)
	}
	return *privKey
}


// The DistributionNode download the data and chuck to sub-hasklink and
// generate the ciphertext and send to SuperNode . Then distribute the task
// and the StorageMiner get the task and download the data.
func Setup(data string,privKey *PrivateKey) ([]byte) {
	m := []byte(data)
	ciphertext,err := Encrypt(&privKey.PublicKey,m)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("ciphertext:",ciphertext)
	return ciphertext
}

// The SuperNode check the StorageMiner's Proof work,then the SuperNode need privKey come from DistributionNode
// and ciphertext come from DistribbutionNode  and chalciphertext generated by self.
func Verify(privKey *PrivateKey,ciphertext []byte,chalciphertext []byte,proof *big.Int) (bool){
	plusCiphertext := AddCipher(&privKey.PublicKey,ciphertext,chalciphertext)
	decryptedAddition,err := Decrypt(privKey,plusCiphertext)
	if err != nil {
		fmt.Println(err)
		return false
	}
	verify := new(big.Int).SetBytes(decryptedAddition)
	fmt.Println("verify:",verify)
	if proof.Cmp(verify) != 0 {
		return false
	}else{
		return true
	}
}

// SuperNode launch the chanllenge random. The SuperNode need the publickKey
// and get some random information come from the blockchain
func Challege(publicKey *PublicKey) ([]byte,*big.Int,error) {
	// todo: the random factor will come from the blockchain
	chal,err := rand.Int(rand.Reader,new(big.Int).SetInt64(999))
	chalciphertext,err := Encrypt(publicKey,chal.Bytes())
	fmt.Println("challenge:",chalciphertext)
	if err != nil {
		fmt.Println(err)
	}
	return chalciphertext,chal,err
}

// StorageMiner proof possession the data locally.The StorageMiner need the
// challenge come from the SuperNode and the data stored locally.
func Proof(storedData string, chal *big.Int) (*big.Int) {
	storedm := []byte(storedData)
	proof := new(big.Int).Add(new(big.Int).SetBytes(storedm),chal)
	fmt.Println("proof:",proof)
	return proof
}